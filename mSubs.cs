using Microsoft.VisualBasic;
using Microsoft.Win32;
using System;
using System.IO;
using System.Media;
using System.Windows.Forms;
using UpgradeHelpers.VB6.Activex;
using UpgradeHelpers.VB6.Gui;
using UpgradeHelpers.VB6.Utils;

namespace ReportPhantom
{
    internal static class msubs
    {
        [STAThread]
        public static void Main()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : Main
            // Purpose   : Startup sub. Checks if executed by user or called into existance by a D3 prog
            // Author    : Walter H. Kiess
            // Date      : 15/05/13
            // Inputs    : INI file
            // Outputs   : Crystal Reports either onscreen or as exported files
            //---------------------------------------------------------------------------------------
            bool ErrSub = false;
            ComponentServerFactory.RegisterClientIPCChannel();

            try
            {
                ErrSub = true;

                SystemEvents.SessionEnding += new SessionEndingEventHandler(SystemEvents_SessionEnding);

                mVars.Debug = true; //To allow recording of the state of the initial INI file read.

                //after that, the INI file setting takes over...
                SetupDebugging();
                SaveINIKeyString("System", "Printed", "False");

                //Get initial INI parameters
                if (!GetINIParms())
                {
                    Dbg.WriteLine("Unable to read INI File, or invalid parameters found: Quitting...");
                    Dbg.Close();
                    Application.Exit();
                }

                //Show form if not hidden, otherwise process report as per INI file parameters
                if (!mVars.Hidden)
                {
                    frmMain.DefInstance.Show();
                    frmMain.DefInstance.lstStatus.AddItem("INI file: " + mVars.INIFilename);
                    Dbg.WriteLine("Starting Main form");
                    Application.Run(frmMain.DefInstance);
                }
                else //Process report, then wait for the next one...kinda like a service...
                {
                    ProcessReport();
                }
                ErrSub = false;
            }
            catch (Exception excep)
            {
                mVars.ErrMsg = excep.Message;
                mVars.StackTrace = excep.StackTrace;

                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    SysErrMsg("mSubs", "Main");
                }
            }
        }

        private static void SystemEvents_SessionEnding(object sender, SessionEndingEventArgs e)
        {
            Dbg.WriteLine("Logoff, Shutdown or Restart detected.");
            SaveINIKeyString("System", "Quit", "True"); //trick program into quitting
        }

        internal static string D3ErrMsg()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : D3ErrMsg
            // Purpose   : Provide explicit error messages re any D3 errors
            // Author    : Walter H. Kiess
            // Date      : 15/05/13
            // Inputs    : Err.Number    Error Number generated by VB
            // Outputs   : D3ErrMsg      Translated D3 Error Description/Message
            //---------------------------------------------------------------------------------------
            bool ErrSub = false;

            string result = String.Empty;
            string strResult = String.Empty;

            try
            {
                ErrSub = true;
                int switchVar = Information.Err().Number;
                if (switchVar == basD3Defs.d3SrvErr_NFile)
                {
                    strResult = "Too many opened files";
                }
                else if (switchVar == basD3Defs.d3SrvErr_Access)
                {
                    strResult = "Item not present or no access to it";
                }
                else if (switchVar == basD3Defs.d3SrvErr_Lock)
                {
                    strResult = "File/Item is locked";
                }
                else if (switchVar == basD3Defs.d3SrvErr_Inval)
                {
                    strResult = "invalid Call";
                }
                else if (switchVar == basD3Defs.d3SrvErr_NoNum)
                {
                    strResult = "Not a Number";
                }
                else if (switchVar == basD3Defs.d3SrvErr_BadF)
                {
                    strResult = "File not opened";
                }
                else if (switchVar == basD3Defs.d3SrvErr_Missing)
                {
                    strResult = "File not present";
                }
                else if (switchVar == basD3Defs.d3SrvErr_Conv)
                {
                    strResult = "Conversion Error";
                }
                else if (switchVar == basD3Defs.d3SrvErr_BadCol)
                {
                    strResult = "Bad column Number/Name";
                }
                else if (switchVar == basD3Defs.d3SrvErr_EOF)
                {
                    strResult = "Reached end-of-file/item";
                }
                else if (switchVar == basD3Defs.d3SrvErr_CallMain)
                {
                    strResult = "Tried to call main as sub";
                }
                else if (switchVar == basD3Defs.d3SrvErr_NotRoot)
                {
                    strResult = "No index found on root statement";
                }
                else if (switchVar == basD3Defs.d3SrvErr_NoIndexId)
                {
                    strResult = "No more index entries";
                }
                else if (switchVar == basD3Defs.d3SrvErr_BadParams)
                {
                    strResult = "Wrong parameter number";
                }
                else if (switchVar == basD3Defs.d3SrvErr_EndList)
                {
                    strResult = "End of List";

                    // D3 Miscellaneous Errors
                    // =======================
                }
                else if (switchVar == basD3Defs.d3MiscErr_Internal)
                {
                    strResult = "Internal Library Failure";
                }
                else if (switchVar == basD3Defs.d3MiscErr_NotImp)
                {
                    strResult = "[002] Not Implemented";
                }
                else if (switchVar == basD3Defs.d3MiscErr_ODBC)
                {
                    strResult = "Domain must be \"ODBC;\"";
                }
                else if (switchVar == basD3Defs.d3MiscErr_Misc)
                {
                    strResult = "Misc Error";

                    // D3/NT File System Interface Errors
                    // ==================================
                    // Most 'normal' exceptions from the FSI are reported as 'General Services Errors'
                    // The following codes are normally trapped by the underlying OCX or automation
                    // servers.
                }
                else if (switchVar == basD3Defs.d3FsiErr_FcbMissing)
                {
                    strResult = "No FCB for the file";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileExist)
                {
                    strResult = "File already exist";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileOpenError)
                {
                    strResult = "Underlying IO error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileCreateError)
                {
                    strResult = "Underlying IO error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileDeleteError)
                {
                    strResult = "Underlying IO error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileReadError)
                {
                    strResult = "Underlying IO error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileWriteError)
                {
                    strResult = "Underlying IO error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileExtendError)
                {
                    strResult = "File size increase error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileSeekError)
                {
                    strResult = "Seek in file error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_AccountMissing)
                {
                    strResult = "Database/Account missing";
                }
                else if (switchVar == basD3Defs.d3FsiErr_NotDptr)
                {
                    strResult = "Item is not a D ptr";
                }
                else if (switchVar == basD3Defs.d3FsiErr_AccountExist)
                {
                    strResult = "Cannt create account";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileTooLarge)
                {
                    strResult = "Not permitted";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileStillOpened)
                {
                    strResult = "File is still opened";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileMappingError)
                {
                    strResult = "View mapping error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_CreateFileMappingError)
                {
                    strResult = "Create file mapping error";
                }
                else if (switchVar == basD3Defs.d3FsiErr_ItemTruncated)
                {
                    strResult = "Large item as truncated";
                }
                else if (switchVar == basD3Defs.d3FsiErr_TooManyExtensions)
                {
                    strResult = "Mapped file was extended too many times";
                }
                else if (switchVar == basD3Defs.d3FsiErr_DptrDeleteError)
                {
                    strResult = "Cannot delete D pointer";
                }
                else if (switchVar == basD3Defs.d3FsiErr_TooManyClients)
                {
                    strResult = "Exceeded licensed clients";
                }
                else if (switchVar == basD3Defs.d3FsiErr_ObsoleteFsiVersion)
                {
                    strResult = "Old fsi version";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileInUse)
                {
                    strResult = "Cannot lock file for exclusive access";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FileRenameError)
                {
                    strResult = "Cannot rename file";
                }
                else if (switchVar == basD3Defs.d3FsiErr_FilesNotOnSameServer)
                {
                    strResult = "Operation requires files to be on same server";
                }
                else if (switchVar == basD3Defs.d3FsiErr_CreateDirectoryError)
                {
                    strResult = "Failed to create a directory";
                }
                else if (switchVar == basD3Defs.d3FsiErr_NoMds)
                {
                    strResult = "Cannot find any MDS";
                }
                else if (switchVar == basD3Defs.d3FsiErr_CorruptedCellLength)
                {
                    strResult = "Corrupted group";
                }
                else if (switchVar == basD3Defs.d3FsiErr_DeleteMissingFile)
                {
                    strResult = "Attempt to delete a missing file (ok)";
                }
                else if (switchVar == basD3Defs.d3FsiErr_DeleteMissingAccount)
                {
                    strResult = "Attempt to delete a missing account (ok)";
                }
                else if (switchVar == basD3Defs.d3FsiErr_CallCorrMissing)
                {
                    strResult = "Missing sub in a CALL file correlative";
                }
                else if (switchVar == basD3Defs.d3FsiErr_CallCorrError)
                {
                    strResult = "Sub error in a CALL file correlative";
                }
                else if (switchVar == basD3Defs.d3FsiErr_MaxQptrDepth)
                {
                    strResult = "Sub error in a CALL file correlative";

                    // D3OleCtl.OCX (only) throws these
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadNtwkHandle)
                {
                    strResult = "Null NetDomain handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadAcntHandle)
                {
                    strResult = "   Database handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadFileHandle)
                {
                    strResult = "    File Var. handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadItemHandle)
                {
                    strResult = "    aPickItem handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadListHandle)
                {
                    strResult = "    Select List handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadRootHandle)
                {
                    strResult = "   BTree Root handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadRuleHandle)
                {
                    strResult = "    Rule Module handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadStrgHandle)
                {
                    strResult = "   aPickString handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadFlatHandle)
                {
                    strResult = "   Static Array handle";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadAmCount)
                {
                    strResult = "";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadVmCount)
                {
                    strResult = "";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadSvmCount)
                {
                    strResult = "";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadVmeHandle)
                {
                    strResult = "[003]";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadTclHandle)
                {
                    strResult = "[003]";
                }
                else if (switchVar == basD3Defs.d3FsiErr_BadCatHandle)
                {
                    strResult = "[003]";

                    // D3 VME Errors
                    // =============
                    // These errors are normally not seen by VB applications.
                }
                else if (switchVar == basD3Defs.d3VmeErr_UdefDllEntry)
                {
                    strResult = "Missing entry table in  DLL";
                }
                else if (switchVar == basD3Defs.d3VmeErr_UdefDll)
                {
                    strResult = "Missing DLL";
                }
                else if (switchVar == basD3Defs.d3VmeErr_MutexPibsCreateError)
                {
                    strResult = "Failed to create PIBS mutex";
                }
                else if (switchVar == basD3Defs.d3VmeErr_MutexPibsWaitError)
                {
                    strResult = "Failed to wait on PIBS mutex";
                }
                else if (switchVar == basD3Defs.d3VmeErr_MutexPibsWaitTimeout)
                {
                    strResult = "Timed out on gettting lock on pibs";
                }
                else if (switchVar == basD3Defs.d3VmeErr_MutexPibsReleaseError)
                {
                    strResult = "Fialed to release pibs mutex";
                }
                else if (switchVar == basD3Defs.d3VmeErr_DiskError)
                {
                    strResult = "Disk error";
                }
                else if (switchVar == basD3Defs.d3VmeErr_NoFreePib)
                {
                    strResult = "All pibs are busy";
                }
                else if (switchVar == basD3Defs.d3VmeErr_AlreadyExists)
                {
                    strResult = "VME is already started or initialized";
                }
                else if (switchVar == basD3Defs.d3VmeErr_NotAPickProcess)
                {
                    strResult = "The thread has no pick object";
                }
                else if (switchVar == basD3Defs.d3VmeErr_BadPib)
                {
                    strResult = "invalid PIB";
                }
                else if (switchVar == basD3Defs.d3VmeErr_GetConsoleModeError)
                {
                    strResult = "Cannot get the console mode";
                }
                else if (switchVar == basD3Defs.d3VmeErr_SetConsoleModeError)
                {
                    strResult = "Cannot program the console";
                }
                else if (switchVar == basD3Defs.d3VmeErr_InvalidConsole)
                {
                    strResult = "Cannot get handles to stdin/out";
                }
                else if (switchVar == basD3Defs.d3VmeErr_TLSAllocError)
                {
                    strResult = "Cannot allocate TLS";
                }
                else if (switchVar == basD3Defs.d3VmeErr_TLSSetError)
                {
                    strResult = "Cannot store data in TLS";
                }
                else if (switchVar == basD3Defs.d3VmeErr_TLSNotSet)
                {
                    strResult = "TLS not initialized";
                }
                else if (switchVar == basD3Defs.d3VmeErr_EventCreateError)
                {
                    strResult = "Event creation error";
                }
                else if (switchVar == basD3Defs.d3VmeErr_BadPibSetProcess)
                {
                    strResult = "No PCB attached to an object";
                }
                else if (switchVar == basD3Defs.d3VmeErr_UdefMode)
                {
                    strResult = "Undefined call to a mode";
                }
                else if (switchVar == basD3Defs.d3VmeErr_ComOpenFail)
                {
                    strResult = "Cannot open COM port";
                }
                else if (switchVar == basD3Defs.d3VmeErr_ComIOError)
                {
                    strResult = "COM IO error";
                }
                else if (switchVar == basD3Defs.d3VmeErr_PrinterError)
                {
                    strResult = "Printer parameter error";
                }
                else if (switchVar == basD3Defs.d3VmeErr_AbortedShutdown)
                {
                    strResult = "Shutdown was aborted";
                }
                else if (switchVar == basD3Defs.d3VmeErr_RemoteNotSup)
                {
                    strResult = "Not suported on remote connections";

                    // D3 RPC Errors
                    // =============
                    // These errors are normally not visible from a user VB application. They
                    // may be used by some system applets
                }
                else if (switchVar == basD3Defs.d3RpcErr_SetServiceStatusError)
                {
                    strResult = "Cannot update status";
                }
                else if (switchVar == basD3Defs.d3RpcErr_StartdispatcherError)
                {
                    strResult = "Cannot start Service Control dispatcher";
                }
                else if (switchVar == basD3Defs.d3RpcErr_CannotInstall)
                {
                    strResult = "Generic \"Unable to install Service\"";
                }
                else if (switchVar == basD3Defs.d3RpcErr_OpenServiceError)
                {
                    strResult = "Cannot open service";
                }
                else if (switchVar == basD3Defs.d3RpcErr_OpenSCManagerError)
                {
                    strResult = "Cannot access Service Control Manager";
                }
                else if (switchVar == basD3Defs.d3RpcErr_CreateServiceError)
                {
                    strResult = "Cannot create service";
                }
                else if (switchVar == basD3Defs.d3RpcErr_BindingError)
                {
                    strResult = "Binding error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_ComposeError)
                {
                    strResult = "StringBindingCompose error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_RegisterIfError)
                {
                    strResult = "Cannot register interface";
                }
                else if (switchVar == basD3Defs.d3RpcErr_InqBindingErr)
                {
                    strResult = "Inq Binding error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_BindingExportErr)
                {
                    strResult = "Export binding failed";
                }
                else if (switchVar == basD3Defs.d3RpcErr_BindingUnexportErr)
                {
                    strResult = "UnExport binding failed";
                }
                else if (switchVar == basD3Defs.d3RpcErr_BindinVectorFreeErr)
                {
                    strResult = "Cannot free binding vector";
                }
                else if (switchVar == basD3Defs.d3RpcErr_BindingImportError)
                {
                    strResult = "Import from name service error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_WaitServerListenError)
                {
                    strResult = "RpcMgmtWaitServerListenError";
                }
                else if (switchVar == basD3Defs.d3RpcErr_NoBinding)
                {
                    strResult = "Cannot get a valid binding handle";
                }
                else if (switchVar == basD3Defs.d3RpcErr_RtException)
                {
                    strResult = "RPC run time exception";
                }
                else if (switchVar == basD3Defs.d3RpcErr_NoProtocol)
                {
                    strResult = "No available protocol";
                }
                else if (switchVar == basD3Defs.d3RpcErr_ListenError)
                {
                    strResult = "RpcServerListen error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_EpRegisterError)
                {
                    strResult = "RpcEpRegister Error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_UnregisterIfErr)
                {
                    strResult = "RpcUnregisterIf error";
                }
                else if (switchVar == basD3Defs.d3RpcErr_MultipleInstance)
                {
                    strResult = "Multiple instance of server";
                }
                else if (switchVar == basD3Defs.d3RpcErr_ServerLock)
                {
                    strResult = "Global server mutex locked";
                }
                else if (switchVar == basD3Defs.d3RpcErr_ServerUnlock)
                {
                    strResult = "Failed to release server mutex";
                }
                else if (switchVar == basD3Defs.d3RpcErr_StartServiceError)
                {
                    strResult = "Cannot start service";
                }
                else if (switchVar == basD3Defs.d3RpcErr_DeleteServiceError)
                {
                    strResult = "Cannot delete service";
                }
                else if (switchVar == basD3Defs.d3RpcErr_ServerNotActivated)
                {
                    strResult = "Cannot delete service";

                    // D3 Host System Errors
                    // =====================
                }
                else if (switchVar == basD3Defs.d3SysErr_MissingVersId)
                {
                    strResult = "Missing resource id in .exe";
                }
                else if (switchVar == basD3Defs.d3SysErr_TlsAllocation)
                {
                    strResult = "Can not allocate Thread Local Storage";
                }
                else if (switchVar == basD3Defs.d3SysErr_TlsGet)
                {
                    strResult = "Can not access Thread Local Storage";
                }
                else if (switchVar == basD3Defs.d3SysErr_TlsSet)
                {
                    strResult = "Can not update Thread Local Storage";
                }
                else if (switchVar == basD3Defs.d3SysErr_Obsolete)
                {
                    strResult = "[006] 4092, or -4 or x7FC";
                }
                else if (switchVar == basD3Defs.d3SysErr_NotImp)
                {
                    strResult = "[006] 4093, or -3 or x7FD";
                }
                else if (switchVar == basD3Defs.d3SysErr_Reserved)
                {
                    strResult = "[006] 4094, or -2 or x7FE";
                }
                else if (switchVar == basD3Defs.d3SysErr_Unknown)
                {
                    strResult = "[001] 4095, or -1 or x7FF";

                    // D3 Flash Interpreter Errors
                    // ===========================
                }
                else if (switchVar == basD3Defs.d3BrmErr_AllocPbError)
                {
                    strResult = "Failed to allocate memory";
                }
                else if (switchVar == basD3Defs.d3BrmErr_RelocPbError)
                {
                    strResult = "Relocation error";
                }
                else if (switchVar == basD3Defs.d3BrmErr_UnhandledDebugInput)
                {
                    strResult = "Runtime class does not support debugger input";
                }
                else if (switchVar == basD3Defs.d3BrmErr_UnhandledInput)
                {
                    strResult = "Runtime class does not support input";
                }
                else if (switchVar == basD3Defs.d3BrmErr_MissingObject)
                {
                    strResult = "No flash object";
                }

                result = strResult;

                ErrSub = false;
                return result;
            }
            catch (Exception excep)
            {
                mVars.ErrMsg = excep.Message;
                mVars.StackTrace = excep.StackTrace;

                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    SysErrMsg("mD3ErrHandler", "D3ErrMsg");
                    return result;
                }
            }
        }

        internal static void GenerateReport(string ReportFilename, string SelectionFormula, string ReportTitle,
            string ReportComments, int Destination, object DestinationFilename = null)
        {
            //---------------------------------------------------------------------------------------
            // Procedure : GenerateReport
            // Purpose   : Setup and generate a Crystal Reports Report
            // Author    : Walter H. Kiess
            // Date      : 16/05/13
            // Inputs    : ReportFileName        The name of the Crystal Reports file
            //             SelectionFormula      The selection formula in CR format
            //             ReportTitle           The Title to show on the report
            //             ReportComments        Custom data, usuall the date range
            //             Destination           The destination, eg. 0=screen, 1=printer, 2=file etc
            //             DestinationFilename   The destination filename if reporting to a file
            // Outputs   : Crystal Reports report
            //---------------------------------------------------------------------------------------

            bool ErrSub = false;
            string Msg = String.Empty;

            //Check the report exists before trying to open it. This will avoid system errors crashing the program.
            if (!File.Exists(ReportFilename))
            {
                string msg = "Unable to locate " + ReportFilename;
                SysMsgBox(msg);
                return;
            }

            try
            {
                ErrSub = true;
                Dbg.WriteLine("Generate Report...");
                Dbg.Indent();

                Msg = String.Empty;

                mVars.cryReport = MemoryHelper.ReleaseAndCleanObject<CRAXDRT.Report>(mVars.cryReport, (CRAXDRT.Report)mVars.cryApplication.OpenReport(ReportFilename, (int)CRAXDRT.CROpenReportMethod.crOpenReportByTempCopy));
                mVars.cryReport.PaperSize = CRAXDRT.CRPaperSize.crPaperA4;

                CRAXDRT.IExportOptions crExportOptions = null;
                if (SetupReportParms(mVars.cryReport))
                {
                    if (SelectionFormula.Length > 0)
                    {
                        Dbg.WriteLine("Setting Report Parameter: Selection Formula..." + SelectionFormula);
                        mVars.cryReport.RecordSelectionFormula = SelectionFormula;
                    }
                    if (ReportComments.Length > 0)
                    {
                        Dbg.WriteLine("Setting Report Parameter: Comments..." + ReportComments);
                        mVars.cryReport.ReportComments = ReportComments;
                    }
                    if (ReportTitle.Length > 0)
                    {
                        Dbg.WriteLine("Setting Report Parameter: Report Title..." + ReportTitle);
                        mVars.cryReport.ReportTitle = ReportTitle;
                    }

                    //Use the line below to see the DSN used to make the connection as part of the title (for testing)
                    //        cryReport.ReportTitle = "(" & cryReport.Database.Tables(1).ConnectionProperties.Item("DSN") & ") " & strReportTitle

                    if (Destination == 0)
                    {
                        Dbg.WriteLine("Destination: Screen");

                        //View Report
                        frmReportView.DefInstance.Show();
                        frmReportView.DefInstance.Maximise();
                        frmReportView.DefInstance.cryView.ReportSource = mVars.cryReport;
                        frmReportView.DefInstance.cryView.ViewReport();
                    }
                    else if (Destination == 1)
                    {
                        Dbg.WriteLine("Destination: Printer");

                        //Print Report
                        mVars.cryReport.PrintOut(false, 1, Type.Missing, Type.Missing, Type.Missing); //No prompt, 1 copy only
                    }
                    else if (Destination == 2)
                    {
                        Dbg.WriteLine("Destination: Export");

                        //Export Report
                        crExportOptions = mVars.cryReport.ExportOptions;
                        crExportOptions.DestinationType = CRAXDRT.CRExportDestinationType.crEDTDiskFile;
                        if (mVars.ExportFilename.Length == 0)
                        {
                            if (mVars.ExportType == CRAXDRT.CRExportFormatType.crEFTExcel80)
                            {
                                crExportOptions.DiskFileName = Strings.Left(mVars.CRFilename, mVars.CRFilename.Length - 3) + "xls";
                            }
                            else if (mVars.ExportType == CRAXDRT.CRExportFormatType.crEFTPortableDocFormat)
                            {
                                crExportOptions.DiskFileName = Strings.Left(mVars.CRFilename, mVars.CRFilename.Length - 3) + "pdf";
                            }
                            else
                            {
                                crExportOptions.DiskFileName = Strings.Left(mVars.CRFilename, mVars.CRFilename.Length - 3) + "exp";
                            }
                        }
                        else
                        {
                            crExportOptions.DiskFileName = mVars.ExportFilename;
                        }
                        Dbg.WriteLine("Destination Path: " + crExportOptions.DiskFileName);
                        crExportOptions.ExcelExportAllPages = true;
                        crExportOptions.ExcelUseConstantColumnWidth = false;
                        crExportOptions.FormatType = mVars.ExportType; //crEFTExcel80
                        crExportOptions.ExcelMaintainColumnAlignment = true;

                        SaveINIKeyString("System", "ExportInProgress", "1"); //Set multiple execution blocking flag
                        mVars.cryReport.DisplayProgressDialog = false;
                        frmMain.DefInstance.lstStatus.AddItem("Exporting...");
                        //Play a sound to let user know prog is running
                        SoundPlayer simpleSound = new SoundPlayer(@"c:\Windows\Media\tada.wav");
                        simpleSound.Play();
                        mVars.cryReport.Export(false); //Don't prompt user
                        SaveINIKeyString("System", "ExportInProgress", "0"); //Reset multiple execution blocking flag
                        SaveINIKeyString("System", "Printed", "True");
                    }
                }
                else
                {
                    Msg = "An unexpected error has occurred whilst generating the report." + mVars.SYS_ADM;
                    SysErrorBox(Msg);
                }

                Dbg.Unindent();
                ErrSub = false;
            }
            catch (Exception excep)
            {
                mVars.ErrMsg = excep.Message;
                mVars.StackTrace = excep.StackTrace;

                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    if (Information.Err().Number == -2147206461)
                    {
                        Msg = "Missing Crystal Reports file." + mVars.CRLF2 +
                                 "The system has attempted to print a report using the Crystal Reports file" + Environment.NewLine +
                                 ReportFilename + Environment.NewLine +
                                 "but the file does not exist or the path to the file is invalid." + mVars.CRLF2 +
                                 "This may occur if the report file has been deleted, renamed, or" + Environment.NewLine +
                                 "moved to another location. It may also occur if the report has been" + Environment.NewLine +
                                 "upgraded recently, but VCA has not been made aware of the new filename." + mVars.CRLF2 +
                                 "Processing will continue as normal without the report being printed." + mVars.SYS_ADM;
                        SysErrorBox(Msg);
                        mVars.cryReport = MemoryHelper.ReleaseAndCleanObject<CRAXDRT.Report>(mVars.cryReport, null);
                        mVars.cryApplication = MemoryHelper.ReleaseAndCleanObject<CRAXDRT.Application>(mVars.cryApplication, null);
                        return;
                    }
                    else
                    {
                        SysErrMsg("mSubs", "GenerateReport");
                        SaveINIKeyString("System", "Quit", "True"); //Force prog to stop at next iteration
                    }
                }
            }
            finally
            {
                SaveINIKeyString("System", "ExportInProgress", "0"); //Reset multiple execution blocking flag
            }
        }

        internal static string GetINIKeyString(string SectionName, string KeyName, string DefaultValue)
        {
            //---------------------------------------------------------------------------------------
            // Procedure : GetINIKeyString
            // Purpose   : Get a value from the INI file under the specified section and key names
            // Author    : Walter H. Kiess
            // Created   : 15/05/13
            // Inputs    : SectionName      The section name in the INI file
            //             KeyName          The Key name in the INI file
            //             DefaultValue     The default return value (if key not found)
            // Outputs   : GetINIKeyString  The returned string value of the INI item
            //
            // Note:      The returned value is the LENGTH of the string in strValue, INCLUDING the
            //            terminating null. If a default value was passed, and the section or
            //            key name are not in the file, that value is returned in strRetValue.
            //            If no default value was passed (""), then lngSuccess will = 0 if not found.
            //-------------------------------------------------------------------------------

            //Pad a string large enough to hold the data.
            string result = String.Empty;
            string RetValue = new String(' ', 2048);
            int Size = RetValue.Length;
            int Success = ReportPhantomSupport.PInvoke.SafeNative.kernel32.GetPrivateProfileString(ref SectionName, KeyName, ref DefaultValue, ref RetValue, Size, ref mVars.INIFilename);

            if (Success != 0)
            {
                result = Strings.Left(RetValue, Success);
            }

            return result;
        }

        internal static bool GetINIParms()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : GetINIParms
            // Date      : 15/05/13
            // Author    : Walter H. Kiess
            // Purpose   : Get report parameters
            // Inputs    : INI File
            // Outputs   : Global vars, GetParms: True=Successful, False=Error getting parms
            //---------------------------------------------------------------------------------------

            bool ErrSub = false;
            bool result = false;
            try
            {
                ErrSub = true;

                Dbg.WriteLine("---------------------------------------------------------------------------------------");
                Dbg.WriteLine("Reading INI file parameters...");
                Dbg.Indent();

                string debugFlag = GetINIKeyString("System", "Debug", "False");
                mVars.Debug = (debugFlag.ToLower() == "true");
                Dbg.WriteLine("Debug=" + mVars.Debug);

                string printedFlag = GetINIKeyString("System", "Printed", "False");
                mVars.Printed = (printedFlag.ToLower() == "true");
                Dbg.WriteLine("Printed=" + mVars.Printed);

                //Check for a quick exit...
                bool quit = false;
                string quitFlag = GetINIKeyString("System", "Quit", "False");
                quit = (quitFlag.ToLower() == "true");
                Dbg.WriteLine("QuitFlag=" + quitFlag);
                if (quit)
                {
                    //Set the Quit Parameter back to False  for next time...
                    SaveINIKeyString("System", "Quit", "False");
                    mVars.Debug = true;
                    Dbg.Unindent();
                    Dbg.WriteLine("Quitting...");
                    Dbg.Close();
                    Application.DoEvents();
                    Environment.Exit(0);
                }

                mVars.CRFilename = GetINIKeyString("System", "Filename", "");
                Dbg.WriteLine("CRFilename=" + mVars.CRFilename);
                if (mVars.CRFilename.Length == 0)
                { //Nuthin to do
                    Dbg.WriteLine("No CRFilename specified...Pausing...");
                    SaveINIKeyString("System", "Pause", "True");
                    return result;
                }
                if (!ValidPath(mVars.CRFilename))
                {
                    Dbg.WriteLine("Invalid path specified in CRFilename...Pausing...");
                    SaveINIKeyString("System", "Pause", "True");
                    return result;
                }

                mVars.ExportFilename = GetINIKeyString("System", "ExportFilename", "");
                Dbg.WriteLine("ExportFilename=" + mVars.ExportFilename);

                if (!ValidPath(mVars.ExportFilename))
                {
                    Dbg.WriteLine("Invalid path specified in ExportFilename...Pausing...");
                    SaveINIKeyString("System", "Pause", "True");
                    return result;
                }

                mVars.SelCrit = GetINIKeyString("System", "SelectionCriteria", "");
                Dbg.WriteLine("SelCrit=" + mVars.SelCrit);

                mVars.Title = GetINIKeyString("System", "Title", "");
                Dbg.WriteLine("Title=" + mVars.Title);

                mVars.Comments = GetINIKeyString("System", "Subtitle", "");
                Dbg.WriteLine("Comments=" + mVars.Comments);

                mVars.DSN = GetINIKeyString("System", "DSN", "");
                Dbg.WriteLine("DSN=" + mVars.DSN);

                string auxVar = GetINIKeyString("System", "Hidden", "False");
                Dbg.WriteLine("Hidden=" + auxVar);
                mVars.Hidden = (Boolean.TryParse(auxVar, out mVars.Hidden)) ? mVars.Hidden : Convert.ToBoolean(Double.Parse(auxVar));

                mVars.ExportType = (CRAXDRT.CRExportFormatType)Convert.ToInt32(Double.Parse(GetINIKeyString("System", "ExportType", ((int)CRAXDRT.CRExportFormatType.crEFTNoFormat).ToString())));
                Dbg.WriteLine("ExportType=" + mVars.ExportType);

                Dbg.Unindent();
                Dbg.WriteLine("---------------------------------------------------------------------------------------");
                result = true;

                ErrSub = false;
                return result;
            }
            catch (Exception excep)
            {
                mVars.ErrMsg = excep.Message;
                mVars.StackTrace = excep.StackTrace;

                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    SysErrMsg("msubs", "GetParms");
                    return result;
                }
            }
        }

        internal static void PrintReport()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : PrintReport
            // Purpose   : Print report based on global var parms (read from INI file)
            // Date      : 15/05/13
            // Author    : Walter H. Kiess
            // Outputs   : CR Report
            //---------------------------------------------------------------------------------------
            bool ErrSub = false;

            //Destination: 0=Screen, 1=Printer, 2=File
            int Destination = 0;

            try
            {
                ErrSub = true;
                Dbg.WriteLine("Print Report...");
                Dbg.Indent();

                //---------------------------------------------------------------------------------------
                if (mVars.Hidden)
                {
                    Destination = (1 - Convert.ToInt32(Double.Parse(GetINIKeyString("System", "ToScreen", "0"))));

                    //Check if report is to be exported
                    if (mVars.ExportType != CRAXDRT.CRExportFormatType.crEFTNoFormat)
                    {
                        Destination = 2; //Export
                    }
                }
                else
                {
                    Destination = (1 - ((int)frmMain.DefInstance.chkToScreen.CheckState));

                    //Check if report is to be exported
                    if (frmMain.DefInstance.chkExportToExcel.CheckState == CheckState.Checked)
                    {
                        mVars.ExportType = CRAXDRT.CRExportFormatType.crEFTExcel80;
                        Destination = 2; //Export
                        frmMain.DefInstance.lstStatus.AddItem("Exporting in Excel format...");
                        Dbg.WriteLine("Exporting to Excel");
                    }
                    if (frmMain.DefInstance.chkExportToPDF.CheckState == CheckState.Checked)
                    {
                        mVars.ExportType = CRAXDRT.CRExportFormatType.crEFTPortableDocFormat;
                        Destination = 2; //Export
                        frmMain.DefInstance.lstStatus.AddItem("Exporting in PDF format...");
                        Dbg.WriteLine("Exporting to PDF");
                    }
                }
                Dbg.WriteLine("Destination=" + Destination);
                Dbg.WriteLine("ExportType=" + mVars.ExportType);

                GenerateReport(mVars.CRFilename, mVars.SelCrit, mVars.Title, mVars.Comments, Destination);

                Dbg.Unindent();
                ErrSub = false;
            }
            catch (Exception excep)
            {
                mVars.ErrMsg = excep.Message;
                mVars.StackTrace = excep.StackTrace;

                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    SysErrMsg("msubs", "PrintReport");
                }
            }
        }

        internal static void SaveINIKeyString(string SectionName, string rKeyName, string Value)
        {
            //-------------------------------------------------------------------------------
            // Procedure : SaveINIKeyString
            // Purpose   : Save the passed value to the INI file under the specified section and key names
            // Author    : Walter H. Kiess
            // Created   : 15/05/13
            // Inputs    : SectionName  The section name in the INI file
            //             KeyName      The Key name in the INI file
            //             Value        The value to save
            //             INIFilename  The globally defined INI filename (including path)
            //             If the key name does not exist, it is created.
            //             If the key name exists, it's value is replaced.
            //
            // Note      : If the INI file does not exist, it is created.
            //             If the section does not exist, it is created.
            //-------------------------------------------------------------------------------

            ReportPhantomSupport.PInvoke.SafeNative.kernel32.WritePrivateProfileString(ref SectionName, rKeyName, Value, ref mVars.INIFilename);
        }

        internal static bool SetupReportParms(CRAXDRT.Report cryReport)
        {
            //-------------------------------------------------------------------------------
            // Procedure : SetupReportParms
            // Purpose   : Setup ODBC report connection parameters for Tables in the Report.
            // Author    : Walter H. Kiess
            // Date      : 15/05/13
            // Inputs    : cryReport        - Opened Report Object
            // Outputs   : SetupReportParms - True=Setup OK, False=Setup Failed
            //-------------------------------------------------------------------------------

            bool ErrSub = false;
            bool result = false;
            try
            {
                ErrSub = true;

                CRAXDRT.ConnectionProperty cryProp = null;

                Dbg.Indent();

                //Set the Table locations for all Tables in the report (CR V10+)
                foreach (CRAXDRT.DatabaseTable cryTable in cryReport.Database.Tables)
                {
                    Dbg.WriteLine("Setting DSN for table: " + cryTable.Name);
                    cryProp = MemoryHelper.ReleaseAndCleanObject<CRAXDRT.ConnectionProperty>(cryProp, (CRAXDRT.ConnectionProperty)cryTable.ConnectionProperties["DSN"]);
                    cryProp.Value = mVars.DSN;

                    cryProp = MemoryHelper.ReleaseAndCleanObject<CRAXDRT.ConnectionProperty>(cryProp, (CRAXDRT.ConnectionProperty)cryTable.ConnectionProperties["UseDSNProperties"]);
                    cryProp.Value = "True";
                }
                Dbg.Unindent();
                result = true;

                ErrSub = false;
                return result;
            }
            catch (Exception excep)
            {
                if (!ErrSub)
                {
                    throw excep;
                }
                else
                {
                    SysErrMsg("mSubs", "SetReportParameters");
                    result = false;
                    return result;
                }
            }
        }

        internal static void SysErrMsg(string FormName, string ProcedureName)
        {
            //-------------------------------------------------------------------------------
            // Procedure : SysErrMsg
            // Purpose   : Formats error info and displays an error box for the user
            // Author    : Walter H. Kiess
            // Date      : 16/05/13
            // Inputs    : FormName         Name of form/module where error occurred
            //             ProcedureName    Name of procedure where error occurred
            //-------------------------------------------------------------------------------

            string Msg = "An unexpected error has occurred in:" + mVars.CRLF2;
            if (Strings.Left(FormName, 3).ToLower() == "frm")
            {
                Msg = Msg + "Form:  ";
            }
            else
            {
                Msg = Msg + "Module:";
            }

            Msg = Msg + "\t\t" + FormName + mVars.CRLF +
                     "Procedure:\t" + ProcedureName + mVars.CRLF2 +
                     "Error reported was:" + mVars.CRLF2 +
                     "Description:" + "\t";
            if (Information.Err().Description == "")
            {
                Msg += mVars.ErrMsg + mVars.CRLF2;
            }
            else
            {
                Msg += Information.Err().Description + mVars.CRLF2;
            }
            Msg += "StackTrace:\t" + mVars.StackTrace;

            string d3ErrMsg = D3ErrMsg();
            if (Information.Err().Number >= basD3Defs.d3BaseErr && d3ErrMsg != string.Empty)
            {
                Msg = Msg + mVars.CRLF + "D3 Description:\t" + d3ErrMsg;
            }

            Msg = Msg + mVars.CRLF2 + "Please contact your System Administrator.";

            SysErrorBox(Msg);
        }

        internal static void SysErrorBox(string Msg)
        {
            //-------------------------------------------------------------------------------
            // Procedure : SysErrorBox
            // Purpose   : Displays an error message box for the user
            // Author    : Walter H. Kiess
            // Date      : 16/05/13
            // Inputs    : Msg      The message to be displayed
            //-------------------------------------------------------------------------------
            string d3ErrMsg = D3ErrMsg();
            if (d3ErrMsg.Length > 0)
            {
                Msg = "D3 System Error:" + mVars.CRLF2 + d3ErrMsg + mVars.CRLF2 + Msg;
            }
            Dbg.WriteLine(Msg);
            MessageBox.Show(Msg, "Critical Error - " + DateTimeHelper.ToString(DateTime.Now), MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        internal static void SysMsgBox(string Msg)
        {
            //-------------------------------------------------------------------------------
            // Procedure : SysMsgBox
            // Purpose   : Displays a message box for the user
            // Author    : Walter H. Kiess
            // Date      : 16/05/13
            // Input     : Msg      the message to be displayed
            //-------------------------------------------------------------------------------
            Dbg.WriteLine(Msg);
            MessageBox.Show(Msg, AssemblyHelper.GetTitle(System.Reflection.Assembly.GetExecutingAssembly()) + " - Message", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
        }

        internal static bool ValidPath(string Filename)
        {
            //---------------------------------------------------------------------------------------
            // Procedure : ValidPath
            // Purpose   : Parse a full filename for a valid pathname
            // Date      : 20/05/13
            // Author    : Walter H. Kiess
            // Inputs    : Filename      - Full Filename
            // Outputs   : ValidPath     - True=Path exists, False=Otherwise
            //---------------------------------------------------------------------------------------
            Scripting.FileSystemObject objFSO = new Scripting.FileSystemObject();
            try
            {
                bool ErrSub = false;
                bool result = false;

                try
                {
                    ErrSub = true;

                    if (Filename.Length == 0)
                    {
                        result = true;
                        return result;
                    }
                    result = objFSO.FolderExists(objFSO.GetParentFolderName(Filename));

                    ErrSub = false;
                    return result;
                }
                catch (Exception excep)
                {
                    mVars.ErrMsg = excep.Message;
                    mVars.StackTrace = excep.StackTrace;

                    if (!ErrSub)
                    {
                        throw excep;
                    }
                    else
                    {
                        SysErrMsg("msubs", "ValidPath");
                        return result;
                    }
                }
            }
            finally
            {
                MemoryHelper.ReleaseAndCleanObject(objFSO);
            }
        }

        private static void ProcessReport()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : ProcessReport
            // Purpose   : Continually process INI file parameters to generate reports and quit
            //             or pause when flag(s) set.
            // Author    : Walter H. Kiess
            // Date      : 16/05/13
            // Inputs    : INI file parameters
            // Outputs   : Crystal Reports either onscreen or as exported files
            //---------------------------------------------------------------------------------------

            //Must softcode this path eventually...
            //Play a sound to let user know prog is running
            SoundPlayer simpleSound = new SoundPlayer(@"c:\Windows\Media\tada.wav");
            simpleSound.Play();

            while (true)
            {
                Application.DoEvents();

                //Check whether to Pause the processing...
                bool pause = false;
                string pauseFlag = GetINIKeyString("System", "Pause", "False");
                Dbg.WriteLine("PauseFlag=" + pauseFlag);
                if (!((Boolean.TryParse(pauseFlag, out pause)) ? pause : Convert.ToBoolean(Double.Parse(pauseFlag))) && !mVars.Printed)
                {
                    //No pause, let's do it!
                    PrintReport();
                    SaveINIKeyString("System", "ExportFilename", ""); //Clear Export filename to signal processing done.
                    Dbg.WriteLine("Done Printing Report.");
                    SaveINIKeyString("System", "Pause", "True");    //Pause processing until the next time the INI file is written
                    Dbg.WriteLine("Pausing after printing...");
                }
                else
                {
                    Dbg.WriteLine("Paused...");
                }
                Dbg.WriteLine("Sleeping 2 secs...");
                ReportPhantomSupport.PInvoke.SafeNative.kernel32.Sleep(2000); //Wait 2 secs, then do it all again

                //if (!GetINIParms())
                //{
                //    Dbg.WriteLine("Unable to read INI File, or invalid parameters found: Quitting...");
                //    Application.Exit();
                //}
                bool result = GetINIParms();
            }
        }

        private static void SetupDebugging()
        {
            //---------------------------------------------------------------------------------------
            // Procedure : SetupDebugging
            // Purpose   : Setup debug log file, debug msgs and begin logging
            // Date      : 20/05/13
            // Author    : Walter H. Kiess
            // Outputs   : Log file
            //---------------------------------------------------------------------------------------
            Dbg.LogOutput("C:\\Temp\\ReportPhantom.log");
            Dbg.InitializeUnhandledExceptionHandler();
            Dbg.Problems.Add(new DbgKey("InvCol"), "Invalid Column Name.",
                new string[] {
                        "A column name in the report has not been defined in the D3 ODBC SQL Table.",
                        "Check the report manually using the Crystal Reports IDE."});

            //Must softcode this path eventually...
            mVars.INIFilename = "\\\\SAPS-SVR01\\Company\\CrystalReports\\" + Path.GetFileNameWithoutExtension(Application.ExecutablePath) + ".ini";
            Dbg.WriteLine("INI Filename=" + mVars.INIFilename);
        }
    }
}